// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package bindings

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// IL1PoolPool is an auto generated low-level Go binding around an user-defined struct.
type IL1PoolPool struct {
	StartTimestamp  uint32
	EndTimestamp    uint32
	Token           common.Address
	TotalAmount     *big.Int
	TotalFee        *big.Int
	TotalFeeClaimed *big.Int
	IsCompleted     bool
}

// IL1PoolUser is an auto generated low-level Go binding around an user-defined struct.
type IL1PoolUser struct {
	IsClaimed   bool
	Token       common.Address
	StartPoolId *big.Int
	EndPoolId   *big.Int
	Amount      *big.Int
}

// L1PoolMetaData contains all meta data concerning the L1Pool contract.
var L1PoolMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorBlockChain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providedAmount\",\"type\":\"uint256\"}],\"name\":\"LessThanMinStakeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LessThanZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"PoolIndex\",\"type\":\"uint256\"}],\"name\":\"NewPoolIsNotCreate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReward\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolIndex\",\"type\":\"uint256\"}],\"name\":\"PoolIsCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"}],\"name\":\"TokenIsAlreadySupported\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenIsNotSupported\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endPoolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ClaimEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolIndex\",\"type\":\"uint256\"}],\"name\":\"CompletePoolEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SetMinStakeAmountEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSupport\",\"type\":\"bool\"}],\"name\":\"SetSupportTokenEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakingETHEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakingWETHEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StarkingERC20Event\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Blockchain\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferAssertTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ClaimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"ClaimSimpleAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"startTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TotalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalFeeClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsCompleted\",\"type\":\"bool\"}],\"internalType\":\"structIL1Pool.Pool[]\",\"name\":\"CompletePools\",\"type\":\"tuple[]\"}],\"name\":\"CompletePoolAndNew\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DepositAndStakingETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositAndStakingWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DepositAndStarking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DepositAndStarkingERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"IsSupportToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"MinStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Pools\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"startTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TotalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalFeeClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsCompleted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReLayer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isSupport\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"startTimes\",\"type\":\"uint32\"}],\"name\":\"SetSupportToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SupportTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Blockchain\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferAssertToBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isClaimed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"StartPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"startTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TotalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalFeeClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsCompleted\",\"type\":\"bool\"}],\"internalType\":\"structIL1Pool.Pool\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getPoolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isClaimed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"StartPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"internalType\":\"structIL1Pool.User[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isClaimed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"StartPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"internalType\":\"structIL1Pool.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_MultisigWallet\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMinStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801562000010575f80fd5b506200001b62000021565b620000d5565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000900460ff1615620000725760405163f92ee8a960e01b815260040160405180910390fd5b80546001600160401b0390811614620000d25780546001600160401b0319166001600160401b0390811782556040519081527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b50565b6139c480620000e35f395ff3fe6080604052600436106101f1575f3560e01c806391d1485411610108578063cb4f04ad1161009d578063f91fa9a81161006d578063f91fa9a8146106be578063f9f3ec9e146106dd578063fa861848146106f0578063faeb96a514610704578063ff2bf64f14610723575f80fd5b8063cb4f04ad14610609578063d547741f1461063d578063dac295681461065c578063f8fcc2aa1461068a575f80fd5b8063a217fddf116100d8578063a217fddf14610599578063bc42493d146105ac578063c4d66de8146105cb578063cb314fab146105ea575f80fd5b806391d148541461053457806395455eef1461055357806396f984e6146105725780639845c5c31461057a575f80fd5b806336568abe116101895780635c975abb116101595780635c975abb14610486578063626417b5146104a95780636d6a78bf146104e05780636f77926b146104f45780638456cb5914610520575f80fd5b806336568abe146103615780633f4ba83a146103805780634663cdc8146103945780635b5b9ea214610400575f80fd5b8063248a9ca3116101c4578063248a9ca3146102e357806327e235e3146103025780632f2ff15d1461032d5780633338562c1461034e575f80fd5b806301ffc9a7146101f557806313e8544e146102295780631ca2f1731461027a5780631d31fac0146102b3575b5f80fd5b348015610200575f80fd5b5061021461020f3660046133b7565b61074f565b60405190151581526020015b60405180910390f35b348015610234575f80fd5b506102486102433660046133f4565b610785565b6040805195151586526001600160a01b039094166020860152928401919091526060830152608082015260a001610220565b348015610285575f80fd5b506102a561029436600461341c565b60056020525f908152604090205481565b604051908152602001610220565b3480156102be575f80fd5b505f546102ce9063ffffffff1681565b60405163ffffffff9091168152602001610220565b3480156102ee575f80fd5b506102a56102fd366004613435565b6107db565b34801561030d575f80fd5b506102a561031c36600461341c565b60026020525f908152604090205481565b348015610338575f80fd5b5061034c61034736600461344c565b6107fb565b005b61034c61035c366004613504565b61081d565b34801561036c575f80fd5b5061034c61037b36600461344c565b610b94565b34801561038b575f80fd5b5061034c610bc7565b34801561039f575f80fd5b506103b36103ae3660046133f4565b610bdc565b6040805163ffffffff98891681529790961660208801526001600160a01b03909416948601949094526060850191909152608084015260a0830191909152151560c082015260e001610220565b34801561040b575f80fd5b5061041f61041a3660046133f4565b610c4d565b6040516102209190815163ffffffff9081168252602080840151909116908201526040808301516001600160a01b031690820152606080830151908201526080808301519082015260a0808301519082015260c09182015115159181019190915260e00190565b348015610491575f80fd5b505f8051602061390f8339815191525460ff16610214565b3480156104b4575f80fd5b506104c86104c3366004613435565b610d2f565b6040516001600160a01b039091168152602001610220565b3480156104eb575f80fd5b5061034c610d57565b3480156104ff575f80fd5b5061051361050e36600461341c565b610dcd565b6040516102209190613650565b34801561052b575f80fd5b5061034c610e7b565b34801561053f575f80fd5b5061021461054e36600461344c565b610e8d565b34801561055e575f80fd5b5061034c61056d36600461341c565b610ec3565b61034c6115f3565b348015610585575f80fd5b5061034c6105943660046133f4565b611900565b3480156105a4575f80fd5b506102a55f81565b3480156105b7575f80fd5b5061034c6105c6366004613435565b611b8d565b3480156105d6575f80fd5b5061034c6105e536600461341c565b611f03565b3480156105f5575f80fd5b5061034c6106043660046133f4565b612034565b348015610614575f80fd5b506102a561062336600461341c565b6001600160a01b03165f9081526004602052604090205490565b348015610648575f80fd5b5061034c61065736600461344c565b612097565b348015610667575f80fd5b5061021461067636600461341c565b60016020525f908152604090205460ff1681565b348015610695575f80fd5b506102a56106a436600461341c565b6001600160a01b03165f9081526003602052604090205490565b3480156106c9575f80fd5b5061034c6106d836600461369d565b6120b3565b61034c6106eb3660046133f4565b61228b565b3480156106fb575f80fd5b506102a561231c565b34801561070f575f80fd5b5061034c61071e3660046136de565b612376565b34801561072e575f80fd5b5061074261073d3660046133f4565b612669565b6040516102209190613720565b5f6001600160e01b03198216637965db0b60e01b148061077f57506301ffc9a760e01b6001600160e01b03198316145b92915050565b6004602052815f5260405f20818154811061079e575f80fd5b5f918252602090912060049091020180546001820154600283015460039093015460ff831695506101009092046001600160a01b03169350919085565b5f9081525f805160206138ef833981519152602052604090206001015490565b610804826107db565b61080d8161272b565b6108178383612735565b50505050565b60ff1961084b60017f33fe247d78fee2e7fd135c405eda4bd2911c0a73c0a81b36c3bcc967dd06e5ae613742565b60405160200161085d91815260200190565b604051602081830303815290604052805190602001201661087d8161272b565b5f5b8251811015610b8f575f83828151811061089b5761089b613755565b60200260200101516040015190505f600160035f846001600160a01b03166001600160a01b031681526020019081526020015f20805490506108dd9190613742565b6001600160a01b0383165f90815260036020526040902080549192506001918390811061090c5761090c613755565b905f5260205f2090600502016004015f6101000a81548160ff02191690831515021790555084838151811061094357610943613755565b60200260200101516080015160035f846001600160a01b03166001600160a01b031681526020019081526020015f20828154811061098357610983613755565b905f5260205f209060050201600201819055505f60035f846001600160a01b03166001600160a01b031681526020019081526020015f2082815481106109cb576109cb613755565b5f91825260208083206005909202909101546001600160a01b0386168352600382526040808420815160e0810190925263ffffffff64010000000090930483168083529454949550939092830191610a24911685613769565b63ffffffff168152602001856001600160a01b0316815260200160035f876001600160a01b03166001600160a01b031681526020019081526020015f208581548110610a7257610a72613755565b5f918252602080832060059283020160019081015485528482018490526040808601859052606095860185905287548083018955978552938290208651979093029092018054868301518786015163ffffffff998a1667ffffffffffffffff1990931692909217640100000000999091169890980297909717600160401b600160e01b031916600160401b6001600160a01b039889160217815593850151918401919091556080840151600284015560a0840151600384015560c0909301516004909201805460ff19169215159290921790915551848152918516917fb6f449f07ceaf55392c9899e0797c6529908ae827c2d498c682e90d42c241167910160405180910390a25050508080610b8790613786565b91505061087f565b505050565b6001600160a01b0381163314610bbd5760405163334bd91960e11b815260040160405180910390fd5b610b8f82826127dd565b5f610bd18161272b565b610bd9612856565b50565b6003602052815f5260405f208181548110610bf5575f80fd5b5f9182526020909120600590910201805460018201546002830154600384015460049094015463ffffffff80851697506401000000008504169550600160401b9093046001600160a01b031693919290919060ff1687565b6040805160e0810182525f8082526020808301829052828401829052606083018290526080830182905260a0830182905260c083018290526001600160a01b03861682526003905291909120805483908110610cab57610cab613755565b5f9182526020918290206040805160e081018252600593909302909101805463ffffffff808216855264010000000082041694840194909452600160401b9093046001600160a01b0316908201526001820154606082015260028201546080820152600382015460a082015260049091015460ff16151560c0820152905092915050565b60068181548110610d3e575f80fd5b5f918252602090912001546001600160a01b0316905081565b610d5f6128b5565b610d676128ec565b5f5b600654811015610db457610da260068281548110610d8957610d89613755565b5f918252602090912001546001600160a01b0316610ec3565b80610dac81613786565b915050610d69565b50610dcb60015f8051602061394f83398151915255565b565b6001600160a01b0381165f908152600460209081526040808320805482518185028101850190935280835260609492939192909184015b82821015610e70575f8481526020908190206040805160a08101825260048602909201805460ff81161515845261010090046001600160a01b03168385015260018082015492840192909252600281015460608401526003015460808301529083529092019101610e04565b505050509050919050565b5f610e858161272b565b610bd961291c565b5f9182525f805160206138ef833981519152602090815260408084206001600160a01b0393909316845291905290205460ff1690565b610ecb6128b5565b610ed36128ec565b6001600160a01b0381165f9081526001602052604090205460ff16610f1b576040516305fd61ad60e01b81526001600160a01b03821660048201526024015b60405180910390fd5b6001600160a01b0381165f908152600360205260408120549003610f5457604051637d58ebb960e01b81525f6004820152602401610f12565b5f5b335f908152600460205260409020548110156115dc57335f908152600460205260409020805482916001600160a01b0385169183908110610f9957610f99613755565b5f91825260209091206004909102015461010090046001600160a01b03160361146e57335f908152600460205260409020805482908110610fdc57610fdc613755565b5f91825260209091206004909102015460ff1615610ffa57506115ca565b6001600160a01b0383165f9081526003602052604081205461101e90600190613742565b335f9081526004602052604090208054919250908390811061104257611042613755565b5f918252602080832060036004909302018201546001600160a01b0388168452919052604090912080548390811061107c5761107c613755565b905f5260205f2090600502016001015f8282546110999190613742565b9091555050335f9081526004602052604081208054829190859081106110c1576110c1613755565b5f91825260208083206004928302016003015433845291905260408220805491935090869081106110f4576110f4613755565b905f5260205f209060040201600101549050838111156111275760405163374c934360e11b815260040160405180910390fd5b805b8481101561127b576001600160a01b0388165f9081526003602052604090205461115590600190613742565b81111561117857604051637d58ebb960e01b815260048101829052602401610f12565b6001600160a01b0388165f9081526003602052604081208054839081106111a1576111a1613755565b905f5260205f2090600502016001015460035f8b6001600160a01b03166001600160a01b031681526020019081526020015f2083815481106111e5576111e5613755565b905f5260205f2090600502016002015485611200919061379e565b61120a91906137b5565b905061121681866137d4565b6001600160a01b038a165f908152600360205260409020805491965082918490811061124457611244613755565b905f5260205f2090600502016003015f82825461126191906137d4565b90915550829150611273905081613786565b915050611129565b505f83116112b75760405162461bcd60e51b8152602060048201526009602482015268139bc814995dd85c9960ba1b6044820152606401610f12565b6112c183836137d4565b335f9081526004602052604090208054919350600191879081106112e7576112e7613755565b5f9182526020909120600490910201805460ff19169115159190911790556001600160a01b03871673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed190161135a57604051339083156108fc029084905f818181858888f19350505050158015611354573d5f803e3d5ffd5b5061140c565b73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc1196001600160a01b038816016113f85760405163a9059cbb60e01b81523360048201526024810183905273c02aaa39b223fe8d0a0e5c4f27ead9083c756cc29063a9059cbb906044016020604051808303815f875af11580156113d4573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061135491906137e7565b61140c6001600160a01b0388163384612964565b6001600160a01b038716337f991c329471ab5230e2301ee30d0d6fba5906e32411d5d154d5a8c278d021a2ab83876114448888613742565b604080519384526020840192909252908201526060810187905260800160405180910390a3505050505b335f90815260046020526040902054600110156115c857335f90815260046020526040902080546114a190600190613742565b815481106114b1576114b1613755565b905f5260205f20906004020160045f336001600160a01b03166001600160a01b031681526020019081526020015f2082815481106114f1576114f1613755565b5f918252602080832084546004938402909101805460ff909216151560ff1983168117825586546001600160a01b03610100918290041602610100600160a81b03199091166001600160a81b03199093169290921791909117815560018086015490820155600280860154908201556003948501549401939093553382529091526040902080548061158557611585613802565b5f8281526020812060045f199093019283020180546001600160a81b03191681556001810182905560028101829055600301559055816115c481613816565b9250505b505b806115d481613831565b915050610f56565b50610bd960015f8051602061394f83398151915255565b6115fb6128b5565b6116036128ec565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee5f5260056020527fa1829a9003092132f585b6ccdd167c19fe9774dbdea4260287e8a8e8ca8185d7543410156116a95773eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee5f5260056020527fa1829a9003092132f585b6ccdd167c19fe9774dbdea4260287e8a8e8ca8185d7546040516327500c6d60e21b81526004810191909152346024820152604401610f12565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee5f90815260036020525f8051602061396f833981519152546116e290600190613742565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee5f90815260036020525f8051602061396f833981519152549192500361173357604051637d58ebb960e01b815260016004820152602401610f12565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee5f5260036020525f8051602061396f83398151915280544291908390811061177257611772613755565b5f91825260209091206005909102015463ffffffff16111561188d57335f908152600460208181526040808420815160a08101835285815273eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee818501818152938201888152606083018881523460808501818152865460018082018955978c52898c2096519a02909501805497516001600160a81b0319909816991515610100600160a81b031916999099176101006001600160a01b03909816979097029690961788559051938701939093559151600286015551600394850155909352525f8051602061396f83398151915280548390811061186557611865613755565b905f5260205f2090600502016001015f82825461188291906137d4565b909155506118b49050565b6118988160016137d4565b604051637d58ebb960e01b8152600401610f1291815260200190565b60405134815233907fe7466ea83435490635fc76a5f33da4815758ab48b1d45858f0452ca6465569379060200160405180910390a250610dcb60015f8051602061394f83398151915255565b6119086128b5565b6119106128ec565b6001600160a01b0382165f9081526001602052604090205460ff16611953576040516305fd61ad60e01b81526001600160a01b0383166004820152602401610f12565b6001600160a01b0382165f908152600560205260409020548110156119af576001600160a01b0382165f90815260056020526040908190205490516327500c6d60e21b8152600481019190915260248101829052604401610f12565b6119c46001600160a01b0383163330846129c3565b6001600160a01b0382165f908152600360205260408120546119e890600190613742565b6001600160a01b0384165f9081526003602052604090208054919250429183908110611a1657611a16613755565b5f91825260209091206005909102015463ffffffff161115611b1657335f908152600460208181526040808420815160a0810183528581526001600160a01b038981168286018181528386018a8152606085018a8152608086018d8152875460018181018a55988d528a8d2097519b029096018054935190951661010002610100600160a81b03199a15159a909a166001600160a81b031990931692909217989098178355965193820193909355945160028601555160039485015584529190529020805483919083908110611aee57611aee613755565b905f5260205f2090600502016001015f828254611b0b91906137d4565b90915550611b329050565b604051637d58ebb960e01b815260048101829052602401610f12565b6040518281526001600160a01b0384169033907f3ac7d3823c11677fba9479ed26f696a3f17e16a5a5c39162fa6d183905aa67359060200160405180910390a350611b8960015f8051602061394f83398151915255565b5050565b611b956128b5565b611b9d6128ec565b73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc25f5260056020527fa550ba85c46b24b567d2e17cd597f2283877afab43603f46d5de7858f1bdb73154811015611c30575f805260056020527f05b8ccbb9d4d8fb16ea74ce3c29a41f1b461fbdaff4714a0d9a8eb05499746bc546040516327500c6d60e21b8152600481019190915260248101829052604401610f12565b6040516323b872dd60e01b81523360048201523060248201526044810182905273c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2906323b872dd906064016020604051808303815f875af1158015611c8b573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611caf91906137e7565b5073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc25f90815260036020525f8051602061392f83398151915254611ce990600190613742565b73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc25f5260036020525f8051602061392f83398151915280549192509082908110611d2957611d29613755565b5f91825260209091206004600590920201015460ff1615611d60576040516311cf1b0760e31b815260048101829052602401610f12565b73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc25f5260036020525f8051602061392f833981519152805442919083908110611d9f57611d9f613755565b5f91825260209091206005909102015463ffffffff161115611eb757335f908152600460208181526040808420815160a08101835285815273c02aaa39b223fe8d0a0e5c4f27ead9083c756cc281850181815293820188815260608301888152608084018b8152855460018181018855968b52888b2095519902909401805496516001600160a01b031661010002610100600160a81b0319991515999099166001600160a81b03199097169690961797909717855551928401929092559351600283015592516003918201559190925290525f8051602061392f833981519152805483919083908110611e9457611e94613755565b905f5260205f2090600502016001015f828254611eb191906137d4565b90915550505b60405182815233907fc138e3bd6d13eefa5cb01c0d35c5794001141efaf4e5ad888cad059935f833839060200160405180910390a250610bd960015f8051602061394f83398151915255565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a008054600160401b810460ff16159067ffffffffffffffff165f81158015611f485750825b90505f8267ffffffffffffffff166001148015611f645750303b155b905081158015611f72575080155b15611f905760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff191660011785558315611fba57845460ff60401b1916600160401b1785555b611fc26129fc565b611fca612a04565b611fd45f87612735565b505f805463ffffffff1916621baf80179055831561202c57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b5f61203e8161272b565b6001600160a01b0383165f8181526005602052604090819020849055517ff54d3b756d286b6b08e5d4eda6dfe5b135664abf029e58e637cbf013c442c9509061208a9085815260200190565b60405180910390a2505050565b6120a0826107db565b6120a98161272b565b61081783836127dd565b60ff196120e160017f33fe247d78fee2e7fd135c405eda4bd2911c0a73c0a81b36c3bcc967dd06e5ae613742565b6040516020016120f391815260200190565b60405160208183030381529060405280519060200120166121138161272b565b6001600160a01b0384165f9081526001602052604090205460ff16612156576040516305fd61ad60e01b81526001600160a01b0385166004820152602401610f12565b8462082750036121e957604051636bb825d760e11b815261753060048201525f90730d7e906bd9cafa154b048cfa766cc1e54e39af9b9063d7704bae90602401602060405180830381865afa1580156121b1573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906121d59190613848565b90506121e385858584612a14565b5061222e565b8461044d03612202576121fd848484612d08565b61222e565b84600a03612215576121fd848484612e7b565b604051639474dee160e01b815260040160405180910390fd5b826001600160a01b0316846001600160a01b03167f08ffba656e4ac665e1aa4bb6a342e1a69d4cc12fd751ac862fa3fe27b0c7524a878560405161227c929190918252602082015260400190565b60405180910390a35050505050565b6122936128b5565b61229b6128ec565b34156122ae576122a96115f3565b612306565b73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc1196001600160a01b038316016122dc576122a981611b8d565b6001600160a01b0382165f9081526001602052604090205460ff1615612306576123068282611900565b611b8960015f8051602061394f83398151915255565b60ff1961234a60017f33fe247d78fee2e7fd135c405eda4bd2911c0a73c0a81b36c3bcc967dd06e5ae613742565b60405160200161235c91815260200190565b604051602081830303815290604052805190602001201681565b5f6123808161272b565b6001600160a01b0384165f9081526001602052604090205460ff16156123cc5760405163411befff60e11b81526001600160a01b03851660048201528315156024820152604401610f12565b6001600160a01b0384165f908152600160209081526040808320805460ff19168715151790556003909152808220815160e08101909252915481906124179063ffffffff168661385f565b63ffffffff908116825285811660208084018290526001600160a01b03808b1660408087018290525f60608089018290526080808a0183905260a0808b0184905260c09a8b018490528c5460018181018f559d85528885208d5160059092020180548e8b01518f890151909a16600160401b02600160401b600160e01b03199a8e166401000000000267ffffffffffffffff19909216938e16939093171798909816178755918b01519b86019b909b559989015160028501559888015160038085019190915597909601516004909201805492151560ff19909316929092179091558652938452828520835160e081019094529083529354919283019161251f911686613769565b63ffffffff90811682526001600160a01b0388811660208085018290525f60408087018290526060808801839052608080890184905260a09889018490528a5460018082018d559b85528585208b5160059092020180548c8801518d870151938c1667ffffffffffffffff199092169190911764010000000091909b160299909917600160401b600160e01b031916600160401b9190981602969096178755880151868a015593870151600286015594860151600385015560c0909501516004909301805460ff1916931515939093179092556006805495860181559092527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f90930180546001600160a01b031916841790555185151581527fc8c34f23fafb34e68119c1d231ef03d0d47225b15e2c4de3efbefa14b0181d86910160405180910390a250505050565b6126a16040518060a001604052805f151581526020015f6001600160a01b031681526020015f81526020015f81526020015f81525090565b6001600160a01b0383165f9081526004602052604090208054839081106126ca576126ca613755565b5f9182526020918290206040805160a081018252600493909302909101805460ff81161515845261010090046001600160a01b0316938301939093526001830154908201526002820154606082015260039091015460808201529392505050565b610bd98133613036565b5f5f805160206138ef83398151915261274e8484610e8d565b6127cd575f848152602082815260408083206001600160a01b03871684529091529020805460ff191660011790556127833390565b6001600160a01b0316836001600160a01b0316857f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a4600191505061077f565b5f91505061077f565b5092915050565b5f5f805160206138ef8339815191526127f68484610e8d565b156127cd575f848152602082815260408083206001600160a01b0387168085529252808320805460ff1916905551339287917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a4600191505061077f565b61285e61306f565b5f8051602061390f833981519152805460ff191681557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a150565b5f8051602061394f8339815191528054600119016128e657604051633ee5aeb560e01b815260040160405180910390fd5b60029055565b5f8051602061390f8339815191525460ff1615610dcb5760405163d93c066560e01b815260040160405180910390fd5b6129246128ec565b5f8051602061390f833981519152805460ff191660011781557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25833612897565b6040516001600160a01b03838116602483015260448201839052610b8f91859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b03838183161783525050505061309e565b6040516001600160a01b0384811660248301528381166044830152606482018390526108179186918216906323b872dd90608401612991565b610dcb6130ff565b612a0c6130ff565b610dcb613148565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b03851601612ac757736ea73e05adc79974b931123675ea8f78ffdacdf063ce0b63ce612a5d83856137d4565b85855a6040516001600160e01b031960e087901b1681526001600160a01b039093166004840152602483019190915260448201526064015f604051808303818588803b158015612aab575f80fd5b505af1158015612abd573d5f803e3d5ffd5b5050505050610817565b73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc1196001600160a01b03851601612bf95760405163095ea7b360e01b8152737ac440cae8eb6328de4fa621163a792c1ea9d4fe6004820152602481018390526001600160a01b0385169063095ea7b3906044016020604051808303815f875af1158015612b4a573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612b6e91906137e7565b50737ac440cae8eb6328de4fa621163a792c1ea9d4fe63f219fa668585855a6040516001600160e01b031960e087901b1681526001600160a01b039485166004820152939092166024840152604483015260648201526084015f604051808303815f87803b158015612bde575f80fd5b505af1158015612bf0573d5f803e3d5ffd5b50505050610817565b60405163095ea7b360e01b8152737ac440cae8eb6328de4fa621163a792c1ea9d4fe6004820152602481018390526001600160a01b0385169063095ea7b3906044016020604051808303815f875af1158015612c57573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612c7b91906137e7565b5073d8a791fe2be73eb6e6cf1eb0cb3f36adc9b3f8f963f219fa668585855a6040516001600160e01b031960e087901b1681526001600160a01b039485166004820152939092166024840152604483015260648201526084015b5f604051808303815f87803b158015612cec575f80fd5b505af1158015612cfe573d5f803e3d5ffd5b5050505050505050565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b03841601612d865760405163cd58657960e01b8152732a3dd3eb832af982ec71669e178424b10dca2ede9063cd586579908390612d6f90600190879084908a905f9060040161387c565b5f604051808303818588803b158015612cec575f80fd5b60405163095ea7b360e01b8152732a3dd3eb832af982ec71669e178424b10dca2ede6004820152602481018290526001600160a01b0384169063095ea7b3906044016020604051808303815f875af1158015612de4573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612e0891906137e7565b5060405163cd58657960e01b8152732a3dd3eb832af982ec71669e178424b10dca2ede9063cd58657990612e49906001908690869089905f9060040161387c565b5f604051808303815f87803b158015612e60575f80fd5b505af1158015612e72573d5f803e3d5ffd5b50505050505050565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeed196001600160a01b03841601612f37577399c9fc46f92e8a1c0dec1b1747d010903e884be1639a2ac6d5650a064586222083855a6040516001600160e01b031960e087901b1681526001600160a01b03909216600483015263ffffffff166024820152606060448201525f60648201526084015f604051808303818589803b158015612f1a575f80fd5b5088f1158015612f2c573d5f803e3d5ffd5b505050505050505050565b5f612f4184613168565b60405163095ea7b360e01b81526010602160991b016004820152602481018490529091506001600160a01b0385169063095ea7b3906044016020604051808303815f875af1158015612f95573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612fb991906137e7565b507399c9fc46f92e8a1c0dec1b1747d010903e884be163838b2520858386865a6040516001600160e01b031960e088901b1681526001600160a01b0395861660048201529385166024850152939091166044830152606482015263ffffffff91909116608482015260c060a48201525f60c482015260e401612cd5565b6130408282610e8d565b611b895760405163e2517d3f60e01b81526001600160a01b038216600482015260248101839052604401610f12565b5f8051602061390f8339815191525460ff16610dcb57604051638dfc202b60e01b815260040160405180910390fd5b5f6130b26001600160a01b03841683613285565b905080515f141580156130d65750808060200190518101906130d491906137e7565b155b15610b8f57604051635274afe760e01b81526001600160a01b0384166004820152602401610f12565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054600160401b900460ff16610dcb57604051631afcd79f60e31b815260040160405180910390fd5b6131506130ff565b5f8051602061390f833981519152805460ff19169055565b5f73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc1196001600160a01b0383160161319c57506006602160991b01919050565b73dac17f958d2ee523a2206206994597c13d831ec6196001600160a01b038316016131dc57507394b008aa00579c1307b0ef2c499ad98a8ce58e58919050565b73a0b86991c6218b36c1d19d4a2e9eb0ce3606eb47196001600160a01b0383160161321c5750730b2c639c533813f4aa9d7837caf62653d097ff85919050565b736b175474e89094c44da98b954eedeac495271d0e196001600160a01b0383160161325c575073da10009cbd5d07dd0cecc66161fc93d7c9000da1919050565b6040516305fd61ad60e01b81526001600160a01b0383166004820152602401610f12565b919050565b606061329283835f613299565b9392505050565b6060814710156132be5760405163cd78605960e01b8152306004820152602401610f12565b5f80856001600160a01b031684866040516132d991906138c2565b5f6040518083038185875af1925050503d805f8114613313576040519150601f19603f3d011682016040523d82523d5f602084013e613318565b606091505b5091509150613328868383613332565b9695505050505050565b606082613347576133428261338e565b613292565b815115801561335e57506001600160a01b0384163b155b1561338757604051639996b31560e01b81526001600160a01b0385166004820152602401610f12565b5080613292565b80511561339e5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b5f602082840312156133c7575f80fd5b81356001600160e01b031981168114613292575f80fd5b80356001600160a01b0381168114613280575f80fd5b5f8060408385031215613405575f80fd5b61340e836133de565b946020939093013593505050565b5f6020828403121561342c575f80fd5b613292826133de565b5f60208284031215613445575f80fd5b5035919050565b5f806040838503121561345d575f80fd5b8235915061346d602084016133de565b90509250929050565b634e487b7160e01b5f52604160045260245ffd5b60405160e0810167ffffffffffffffff811182821017156134ad576134ad613476565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156134dc576134dc613476565b604052919050565b803563ffffffff81168114613280575f80fd5b8015158114610bd9575f80fd5b5f6020808385031215613515575f80fd5b823567ffffffffffffffff8082111561352c575f80fd5b818501915085601f83011261353f575f80fd5b81358181111561355157613551613476565b61355f848260051b016134b3565b818152848101925060e091820284018501918883111561357d575f80fd5b938501935b8285101561360c5780858a031215613599575f8081fd5b6135a161348a565b6135aa866134e4565b81526135b78787016134e4565b8782015260406135c88188016133de565b90820152606086810135908201526080808701359082015260a0808701359082015260c0808701356135f9816134f7565b9082015284529384019392850192613582565b50979650505050505050565b8051151582526020808201516001600160a01b0316908301526040808201519083015260608082015190830152608090810151910152565b602080825282518282018190525f9190848201906040850190845b818110156136915761367e838551613618565b9284019260a0929092019160010161366b565b50909695505050505050565b5f805f80608085870312156136b0575f80fd5b843593506136c0602086016133de565b92506136ce604086016133de565b9396929550929360600135925050565b5f805f606084860312156136f0575f80fd5b6136f9846133de565b92506020840135613709816134f7565b9150613717604085016134e4565b90509250925092565b60a0810161077f8284613618565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561077f5761077f61372e565b634e487b7160e01b5f52603260045260245ffd5b63ffffffff8181168382160190808211156127d6576127d661372e565b5f600182016137975761379761372e565b5060010190565b808202811582820484141761077f5761077f61372e565b5f826137cf57634e487b7160e01b5f52601260045260245ffd5b500490565b8082018082111561077f5761077f61372e565b5f602082840312156137f7575f80fd5b8151613292816134f7565b634e487b7160e01b5f52603160045260245ffd5b5f600160ff1b820161382a5761382a61372e565b505f190190565b5f6001600160ff1b0182016137975761379761372e565b5f60208284031215613858575f80fd5b5051919050565b63ffffffff8281168282160390808211156127d6576127d661372e565b63ffffffff9590951685526001600160a01b039384166020860152604085019290925290911660608301521515608082015260c060a082018190525f9082015260e00190565b5f82515f5b818110156138e157602081860181015185830152016138c7565b505f92019182525091905056fe02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800cd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f0330067aa9b7d2b6d14f3837d07b1073399a41e4104b1d98f169f02cc04f44f14f4b09b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f0040c35f83c179e47de306c9fe55fdc60064f11dd52adb51ab61b5643ee626f98da264697066735822122020f74d881cce9dc5dfce0835a0129840d98352b4e528ce798e075e8b0bb3385164736f6c63430008140033",
}

// L1PoolABI is the input ABI used to generate the binding from.
// Deprecated: Use L1PoolMetaData.ABI instead.
var L1PoolABI = L1PoolMetaData.ABI

// L1PoolBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use L1PoolMetaData.Bin instead.
var L1PoolBin = L1PoolMetaData.Bin

// DeployL1Pool deploys a new Ethereum contract, binding an instance of L1Pool to it.
func DeployL1Pool(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *L1Pool, error) {
	parsed, err := L1PoolMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(L1PoolBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &L1Pool{L1PoolCaller: L1PoolCaller{contract: contract}, L1PoolTransactor: L1PoolTransactor{contract: contract}, L1PoolFilterer: L1PoolFilterer{contract: contract}}, nil
}

// L1Pool is an auto generated Go binding around an Ethereum contract.
type L1Pool struct {
	L1PoolCaller     // Read-only binding to the contract
	L1PoolTransactor // Write-only binding to the contract
	L1PoolFilterer   // Log filterer for contract events
}

// L1PoolCaller is an auto generated read-only Go binding around an Ethereum contract.
type L1PoolCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// L1PoolTransactor is an auto generated write-only Go binding around an Ethereum contract.
type L1PoolTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// L1PoolFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type L1PoolFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// L1PoolSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type L1PoolSession struct {
	Contract     *L1Pool           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// L1PoolCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type L1PoolCallerSession struct {
	Contract *L1PoolCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// L1PoolTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type L1PoolTransactorSession struct {
	Contract     *L1PoolTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// L1PoolRaw is an auto generated low-level Go binding around an Ethereum contract.
type L1PoolRaw struct {
	Contract *L1Pool // Generic contract binding to access the raw methods on
}

// L1PoolCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type L1PoolCallerRaw struct {
	Contract *L1PoolCaller // Generic read-only contract binding to access the raw methods on
}

// L1PoolTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type L1PoolTransactorRaw struct {
	Contract *L1PoolTransactor // Generic write-only contract binding to access the raw methods on
}

// NewL1Pool creates a new instance of L1Pool, bound to a specific deployed contract.
func NewL1Pool(address common.Address, backend bind.ContractBackend) (*L1Pool, error) {
	contract, err := bindL1Pool(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &L1Pool{L1PoolCaller: L1PoolCaller{contract: contract}, L1PoolTransactor: L1PoolTransactor{contract: contract}, L1PoolFilterer: L1PoolFilterer{contract: contract}}, nil
}

// NewL1PoolCaller creates a new read-only instance of L1Pool, bound to a specific deployed contract.
func NewL1PoolCaller(address common.Address, caller bind.ContractCaller) (*L1PoolCaller, error) {
	contract, err := bindL1Pool(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &L1PoolCaller{contract: contract}, nil
}

// NewL1PoolTransactor creates a new write-only instance of L1Pool, bound to a specific deployed contract.
func NewL1PoolTransactor(address common.Address, transactor bind.ContractTransactor) (*L1PoolTransactor, error) {
	contract, err := bindL1Pool(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &L1PoolTransactor{contract: contract}, nil
}

// NewL1PoolFilterer creates a new log filterer instance of L1Pool, bound to a specific deployed contract.
func NewL1PoolFilterer(address common.Address, filterer bind.ContractFilterer) (*L1PoolFilterer, error) {
	contract, err := bindL1Pool(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &L1PoolFilterer{contract: contract}, nil
}

// bindL1Pool binds a generic wrapper to an already deployed contract.
func bindL1Pool(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := L1PoolMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_L1Pool *L1PoolRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _L1Pool.Contract.L1PoolCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_L1Pool *L1PoolRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _L1Pool.Contract.L1PoolTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_L1Pool *L1PoolRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _L1Pool.Contract.L1PoolTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_L1Pool *L1PoolCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _L1Pool.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_L1Pool *L1PoolTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _L1Pool.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_L1Pool *L1PoolTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _L1Pool.Contract.contract.Transact(opts, method, params...)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_L1Pool *L1PoolCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_L1Pool *L1PoolSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _L1Pool.Contract.DEFAULTADMINROLE(&_L1Pool.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_L1Pool *L1PoolCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _L1Pool.Contract.DEFAULTADMINROLE(&_L1Pool.CallOpts)
}

// IsSupportToken is a free data retrieval call binding the contract method 0xdac29568.
//
// Solidity: function IsSupportToken(address ) view returns(bool)
func (_L1Pool *L1PoolCaller) IsSupportToken(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "IsSupportToken", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSupportToken is a free data retrieval call binding the contract method 0xdac29568.
//
// Solidity: function IsSupportToken(address ) view returns(bool)
func (_L1Pool *L1PoolSession) IsSupportToken(arg0 common.Address) (bool, error) {
	return _L1Pool.Contract.IsSupportToken(&_L1Pool.CallOpts, arg0)
}

// IsSupportToken is a free data retrieval call binding the contract method 0xdac29568.
//
// Solidity: function IsSupportToken(address ) view returns(bool)
func (_L1Pool *L1PoolCallerSession) IsSupportToken(arg0 common.Address) (bool, error) {
	return _L1Pool.Contract.IsSupportToken(&_L1Pool.CallOpts, arg0)
}

// MinStakeAmount is a free data retrieval call binding the contract method 0x1ca2f173.
//
// Solidity: function MinStakeAmount(address ) view returns(uint256)
func (_L1Pool *L1PoolCaller) MinStakeAmount(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "MinStakeAmount", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinStakeAmount is a free data retrieval call binding the contract method 0x1ca2f173.
//
// Solidity: function MinStakeAmount(address ) view returns(uint256)
func (_L1Pool *L1PoolSession) MinStakeAmount(arg0 common.Address) (*big.Int, error) {
	return _L1Pool.Contract.MinStakeAmount(&_L1Pool.CallOpts, arg0)
}

// MinStakeAmount is a free data retrieval call binding the contract method 0x1ca2f173.
//
// Solidity: function MinStakeAmount(address ) view returns(uint256)
func (_L1Pool *L1PoolCallerSession) MinStakeAmount(arg0 common.Address) (*big.Int, error) {
	return _L1Pool.Contract.MinStakeAmount(&_L1Pool.CallOpts, arg0)
}

// Pools is a free data retrieval call binding the contract method 0x4663cdc8.
//
// Solidity: function Pools(address , uint256 ) view returns(uint32 startTimestamp, uint32 endTimestamp, address token, uint256 TotalAmount, uint256 TotalFee, uint256 TotalFeeClaimed, bool IsCompleted)
func (_L1Pool *L1PoolCaller) Pools(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (struct {
	StartTimestamp  uint32
	EndTimestamp    uint32
	Token           common.Address
	TotalAmount     *big.Int
	TotalFee        *big.Int
	TotalFeeClaimed *big.Int
	IsCompleted     bool
}, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "Pools", arg0, arg1)

	outstruct := new(struct {
		StartTimestamp  uint32
		EndTimestamp    uint32
		Token           common.Address
		TotalAmount     *big.Int
		TotalFee        *big.Int
		TotalFeeClaimed *big.Int
		IsCompleted     bool
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.StartTimestamp = *abi.ConvertType(out[0], new(uint32)).(*uint32)
	outstruct.EndTimestamp = *abi.ConvertType(out[1], new(uint32)).(*uint32)
	outstruct.Token = *abi.ConvertType(out[2], new(common.Address)).(*common.Address)
	outstruct.TotalAmount = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.TotalFee = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)
	outstruct.TotalFeeClaimed = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)
	outstruct.IsCompleted = *abi.ConvertType(out[6], new(bool)).(*bool)

	return *outstruct, err

}

// Pools is a free data retrieval call binding the contract method 0x4663cdc8.
//
// Solidity: function Pools(address , uint256 ) view returns(uint32 startTimestamp, uint32 endTimestamp, address token, uint256 TotalAmount, uint256 TotalFee, uint256 TotalFeeClaimed, bool IsCompleted)
func (_L1Pool *L1PoolSession) Pools(arg0 common.Address, arg1 *big.Int) (struct {
	StartTimestamp  uint32
	EndTimestamp    uint32
	Token           common.Address
	TotalAmount     *big.Int
	TotalFee        *big.Int
	TotalFeeClaimed *big.Int
	IsCompleted     bool
}, error) {
	return _L1Pool.Contract.Pools(&_L1Pool.CallOpts, arg0, arg1)
}

// Pools is a free data retrieval call binding the contract method 0x4663cdc8.
//
// Solidity: function Pools(address , uint256 ) view returns(uint32 startTimestamp, uint32 endTimestamp, address token, uint256 TotalAmount, uint256 TotalFee, uint256 TotalFeeClaimed, bool IsCompleted)
func (_L1Pool *L1PoolCallerSession) Pools(arg0 common.Address, arg1 *big.Int) (struct {
	StartTimestamp  uint32
	EndTimestamp    uint32
	Token           common.Address
	TotalAmount     *big.Int
	TotalFee        *big.Int
	TotalFeeClaimed *big.Int
	IsCompleted     bool
}, error) {
	return _L1Pool.Contract.Pools(&_L1Pool.CallOpts, arg0, arg1)
}

// ReLayer is a free data retrieval call binding the contract method 0xfa861848.
//
// Solidity: function ReLayer() view returns(bytes32)
func (_L1Pool *L1PoolCaller) ReLayer(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "ReLayer")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ReLayer is a free data retrieval call binding the contract method 0xfa861848.
//
// Solidity: function ReLayer() view returns(bytes32)
func (_L1Pool *L1PoolSession) ReLayer() ([32]byte, error) {
	return _L1Pool.Contract.ReLayer(&_L1Pool.CallOpts)
}

// ReLayer is a free data retrieval call binding the contract method 0xfa861848.
//
// Solidity: function ReLayer() view returns(bytes32)
func (_L1Pool *L1PoolCallerSession) ReLayer() ([32]byte, error) {
	return _L1Pool.Contract.ReLayer(&_L1Pool.CallOpts)
}

// SupportTokens is a free data retrieval call binding the contract method 0x626417b5.
//
// Solidity: function SupportTokens(uint256 ) view returns(address)
func (_L1Pool *L1PoolCaller) SupportTokens(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "SupportTokens", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SupportTokens is a free data retrieval call binding the contract method 0x626417b5.
//
// Solidity: function SupportTokens(uint256 ) view returns(address)
func (_L1Pool *L1PoolSession) SupportTokens(arg0 *big.Int) (common.Address, error) {
	return _L1Pool.Contract.SupportTokens(&_L1Pool.CallOpts, arg0)
}

// SupportTokens is a free data retrieval call binding the contract method 0x626417b5.
//
// Solidity: function SupportTokens(uint256 ) view returns(address)
func (_L1Pool *L1PoolCallerSession) SupportTokens(arg0 *big.Int) (common.Address, error) {
	return _L1Pool.Contract.SupportTokens(&_L1Pool.CallOpts, arg0)
}

// Users is a free data retrieval call binding the contract method 0x13e8544e.
//
// Solidity: function Users(address , uint256 ) view returns(bool isClaimed, address token, uint256 StartPoolId, uint256 EndPoolId, uint256 Amount)
func (_L1Pool *L1PoolCaller) Users(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (struct {
	IsClaimed   bool
	Token       common.Address
	StartPoolId *big.Int
	EndPoolId   *big.Int
	Amount      *big.Int
}, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "Users", arg0, arg1)

	outstruct := new(struct {
		IsClaimed   bool
		Token       common.Address
		StartPoolId *big.Int
		EndPoolId   *big.Int
		Amount      *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.IsClaimed = *abi.ConvertType(out[0], new(bool)).(*bool)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.StartPoolId = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.EndPoolId = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.Amount = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// Users is a free data retrieval call binding the contract method 0x13e8544e.
//
// Solidity: function Users(address , uint256 ) view returns(bool isClaimed, address token, uint256 StartPoolId, uint256 EndPoolId, uint256 Amount)
func (_L1Pool *L1PoolSession) Users(arg0 common.Address, arg1 *big.Int) (struct {
	IsClaimed   bool
	Token       common.Address
	StartPoolId *big.Int
	EndPoolId   *big.Int
	Amount      *big.Int
}, error) {
	return _L1Pool.Contract.Users(&_L1Pool.CallOpts, arg0, arg1)
}

// Users is a free data retrieval call binding the contract method 0x13e8544e.
//
// Solidity: function Users(address , uint256 ) view returns(bool isClaimed, address token, uint256 StartPoolId, uint256 EndPoolId, uint256 Amount)
func (_L1Pool *L1PoolCallerSession) Users(arg0 common.Address, arg1 *big.Int) (struct {
	IsClaimed   bool
	Token       common.Address
	StartPoolId *big.Int
	EndPoolId   *big.Int
	Amount      *big.Int
}, error) {
	return _L1Pool.Contract.Users(&_L1Pool.CallOpts, arg0, arg1)
}

// Balances is a free data retrieval call binding the contract method 0x27e235e3.
//
// Solidity: function balances(address ) view returns(uint256)
func (_L1Pool *L1PoolCaller) Balances(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "balances", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Balances is a free data retrieval call binding the contract method 0x27e235e3.
//
// Solidity: function balances(address ) view returns(uint256)
func (_L1Pool *L1PoolSession) Balances(arg0 common.Address) (*big.Int, error) {
	return _L1Pool.Contract.Balances(&_L1Pool.CallOpts, arg0)
}

// Balances is a free data retrieval call binding the contract method 0x27e235e3.
//
// Solidity: function balances(address ) view returns(uint256)
func (_L1Pool *L1PoolCallerSession) Balances(arg0 common.Address) (*big.Int, error) {
	return _L1Pool.Contract.Balances(&_L1Pool.CallOpts, arg0)
}

// GetPool is a free data retrieval call binding the contract method 0x5b5b9ea2.
//
// Solidity: function getPool(address _token, uint256 _index) view returns((uint32,uint32,address,uint256,uint256,uint256,bool))
func (_L1Pool *L1PoolCaller) GetPool(opts *bind.CallOpts, _token common.Address, _index *big.Int) (IL1PoolPool, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "getPool", _token, _index)

	if err != nil {
		return *new(IL1PoolPool), err
	}

	out0 := *abi.ConvertType(out[0], new(IL1PoolPool)).(*IL1PoolPool)

	return out0, err

}

// GetPool is a free data retrieval call binding the contract method 0x5b5b9ea2.
//
// Solidity: function getPool(address _token, uint256 _index) view returns((uint32,uint32,address,uint256,uint256,uint256,bool))
func (_L1Pool *L1PoolSession) GetPool(_token common.Address, _index *big.Int) (IL1PoolPool, error) {
	return _L1Pool.Contract.GetPool(&_L1Pool.CallOpts, _token, _index)
}

// GetPool is a free data retrieval call binding the contract method 0x5b5b9ea2.
//
// Solidity: function getPool(address _token, uint256 _index) view returns((uint32,uint32,address,uint256,uint256,uint256,bool))
func (_L1Pool *L1PoolCallerSession) GetPool(_token common.Address, _index *big.Int) (IL1PoolPool, error) {
	return _L1Pool.Contract.GetPool(&_L1Pool.CallOpts, _token, _index)
}

// GetPoolLength is a free data retrieval call binding the contract method 0xf8fcc2aa.
//
// Solidity: function getPoolLength(address _token) view returns(uint256)
func (_L1Pool *L1PoolCaller) GetPoolLength(opts *bind.CallOpts, _token common.Address) (*big.Int, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "getPoolLength", _token)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetPoolLength is a free data retrieval call binding the contract method 0xf8fcc2aa.
//
// Solidity: function getPoolLength(address _token) view returns(uint256)
func (_L1Pool *L1PoolSession) GetPoolLength(_token common.Address) (*big.Int, error) {
	return _L1Pool.Contract.GetPoolLength(&_L1Pool.CallOpts, _token)
}

// GetPoolLength is a free data retrieval call binding the contract method 0xf8fcc2aa.
//
// Solidity: function getPoolLength(address _token) view returns(uint256)
func (_L1Pool *L1PoolCallerSession) GetPoolLength(_token common.Address) (*big.Int, error) {
	return _L1Pool.Contract.GetPoolLength(&_L1Pool.CallOpts, _token)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_L1Pool *L1PoolCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_L1Pool *L1PoolSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _L1Pool.Contract.GetRoleAdmin(&_L1Pool.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_L1Pool *L1PoolCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _L1Pool.Contract.GetRoleAdmin(&_L1Pool.CallOpts, role)
}

// GetUser is a free data retrieval call binding the contract method 0x6f77926b.
//
// Solidity: function getUser(address _user) view returns((bool,address,uint256,uint256,uint256)[])
func (_L1Pool *L1PoolCaller) GetUser(opts *bind.CallOpts, _user common.Address) ([]IL1PoolUser, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "getUser", _user)

	if err != nil {
		return *new([]IL1PoolUser), err
	}

	out0 := *abi.ConvertType(out[0], new([]IL1PoolUser)).(*[]IL1PoolUser)

	return out0, err

}

// GetUser is a free data retrieval call binding the contract method 0x6f77926b.
//
// Solidity: function getUser(address _user) view returns((bool,address,uint256,uint256,uint256)[])
func (_L1Pool *L1PoolSession) GetUser(_user common.Address) ([]IL1PoolUser, error) {
	return _L1Pool.Contract.GetUser(&_L1Pool.CallOpts, _user)
}

// GetUser is a free data retrieval call binding the contract method 0x6f77926b.
//
// Solidity: function getUser(address _user) view returns((bool,address,uint256,uint256,uint256)[])
func (_L1Pool *L1PoolCallerSession) GetUser(_user common.Address) ([]IL1PoolUser, error) {
	return _L1Pool.Contract.GetUser(&_L1Pool.CallOpts, _user)
}

// GetUser0 is a free data retrieval call binding the contract method 0xff2bf64f.
//
// Solidity: function getUser(address _user, uint256 _index) view returns((bool,address,uint256,uint256,uint256))
func (_L1Pool *L1PoolCaller) GetUser0(opts *bind.CallOpts, _user common.Address, _index *big.Int) (IL1PoolUser, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "getUser0", _user, _index)

	if err != nil {
		return *new(IL1PoolUser), err
	}

	out0 := *abi.ConvertType(out[0], new(IL1PoolUser)).(*IL1PoolUser)

	return out0, err

}

// GetUser0 is a free data retrieval call binding the contract method 0xff2bf64f.
//
// Solidity: function getUser(address _user, uint256 _index) view returns((bool,address,uint256,uint256,uint256))
func (_L1Pool *L1PoolSession) GetUser0(_user common.Address, _index *big.Int) (IL1PoolUser, error) {
	return _L1Pool.Contract.GetUser0(&_L1Pool.CallOpts, _user, _index)
}

// GetUser0 is a free data retrieval call binding the contract method 0xff2bf64f.
//
// Solidity: function getUser(address _user, uint256 _index) view returns((bool,address,uint256,uint256,uint256))
func (_L1Pool *L1PoolCallerSession) GetUser0(_user common.Address, _index *big.Int) (IL1PoolUser, error) {
	return _L1Pool.Contract.GetUser0(&_L1Pool.CallOpts, _user, _index)
}

// GetUserLength is a free data retrieval call binding the contract method 0xcb4f04ad.
//
// Solidity: function getUserLength(address _user) view returns(uint256)
func (_L1Pool *L1PoolCaller) GetUserLength(opts *bind.CallOpts, _user common.Address) (*big.Int, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "getUserLength", _user)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetUserLength is a free data retrieval call binding the contract method 0xcb4f04ad.
//
// Solidity: function getUserLength(address _user) view returns(uint256)
func (_L1Pool *L1PoolSession) GetUserLength(_user common.Address) (*big.Int, error) {
	return _L1Pool.Contract.GetUserLength(&_L1Pool.CallOpts, _user)
}

// GetUserLength is a free data retrieval call binding the contract method 0xcb4f04ad.
//
// Solidity: function getUserLength(address _user) view returns(uint256)
func (_L1Pool *L1PoolCallerSession) GetUserLength(_user common.Address) (*big.Int, error) {
	return _L1Pool.Contract.GetUserLength(&_L1Pool.CallOpts, _user)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_L1Pool *L1PoolCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_L1Pool *L1PoolSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _L1Pool.Contract.HasRole(&_L1Pool.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_L1Pool *L1PoolCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _L1Pool.Contract.HasRole(&_L1Pool.CallOpts, role, account)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_L1Pool *L1PoolCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_L1Pool *L1PoolSession) Paused() (bool, error) {
	return _L1Pool.Contract.Paused(&_L1Pool.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_L1Pool *L1PoolCallerSession) Paused() (bool, error) {
	return _L1Pool.Contract.Paused(&_L1Pool.CallOpts)
}

// PeriodTime is a free data retrieval call binding the contract method 0x1d31fac0.
//
// Solidity: function periodTime() view returns(uint32)
func (_L1Pool *L1PoolCaller) PeriodTime(opts *bind.CallOpts) (uint32, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "periodTime")

	if err != nil {
		return *new(uint32), err
	}

	out0 := *abi.ConvertType(out[0], new(uint32)).(*uint32)

	return out0, err

}

// PeriodTime is a free data retrieval call binding the contract method 0x1d31fac0.
//
// Solidity: function periodTime() view returns(uint32)
func (_L1Pool *L1PoolSession) PeriodTime() (uint32, error) {
	return _L1Pool.Contract.PeriodTime(&_L1Pool.CallOpts)
}

// PeriodTime is a free data retrieval call binding the contract method 0x1d31fac0.
//
// Solidity: function periodTime() view returns(uint32)
func (_L1Pool *L1PoolCallerSession) PeriodTime() (uint32, error) {
	return _L1Pool.Contract.PeriodTime(&_L1Pool.CallOpts)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_L1Pool *L1PoolCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _L1Pool.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_L1Pool *L1PoolSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _L1Pool.Contract.SupportsInterface(&_L1Pool.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_L1Pool *L1PoolCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _L1Pool.Contract.SupportsInterface(&_L1Pool.CallOpts, interfaceId)
}

// ClaimAll is a paid mutator transaction binding the contract method 0x6d6a78bf.
//
// Solidity: function ClaimAll() returns()
func (_L1Pool *L1PoolTransactor) ClaimAll(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "ClaimAll")
}

// ClaimAll is a paid mutator transaction binding the contract method 0x6d6a78bf.
//
// Solidity: function ClaimAll() returns()
func (_L1Pool *L1PoolSession) ClaimAll() (*types.Transaction, error) {
	return _L1Pool.Contract.ClaimAll(&_L1Pool.TransactOpts)
}

// ClaimAll is a paid mutator transaction binding the contract method 0x6d6a78bf.
//
// Solidity: function ClaimAll() returns()
func (_L1Pool *L1PoolTransactorSession) ClaimAll() (*types.Transaction, error) {
	return _L1Pool.Contract.ClaimAll(&_L1Pool.TransactOpts)
}

// ClaimSimpleAsset is a paid mutator transaction binding the contract method 0x95455eef.
//
// Solidity: function ClaimSimpleAsset(address _token) returns()
func (_L1Pool *L1PoolTransactor) ClaimSimpleAsset(opts *bind.TransactOpts, _token common.Address) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "ClaimSimpleAsset", _token)
}

// ClaimSimpleAsset is a paid mutator transaction binding the contract method 0x95455eef.
//
// Solidity: function ClaimSimpleAsset(address _token) returns()
func (_L1Pool *L1PoolSession) ClaimSimpleAsset(_token common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.ClaimSimpleAsset(&_L1Pool.TransactOpts, _token)
}

// ClaimSimpleAsset is a paid mutator transaction binding the contract method 0x95455eef.
//
// Solidity: function ClaimSimpleAsset(address _token) returns()
func (_L1Pool *L1PoolTransactorSession) ClaimSimpleAsset(_token common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.ClaimSimpleAsset(&_L1Pool.TransactOpts, _token)
}

// CompletePoolAndNew is a paid mutator transaction binding the contract method 0x3338562c.
//
// Solidity: function CompletePoolAndNew((uint32,uint32,address,uint256,uint256,uint256,bool)[] CompletePools) payable returns()
func (_L1Pool *L1PoolTransactor) CompletePoolAndNew(opts *bind.TransactOpts, CompletePools []IL1PoolPool) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "CompletePoolAndNew", CompletePools)
}

// CompletePoolAndNew is a paid mutator transaction binding the contract method 0x3338562c.
//
// Solidity: function CompletePoolAndNew((uint32,uint32,address,uint256,uint256,uint256,bool)[] CompletePools) payable returns()
func (_L1Pool *L1PoolSession) CompletePoolAndNew(CompletePools []IL1PoolPool) (*types.Transaction, error) {
	return _L1Pool.Contract.CompletePoolAndNew(&_L1Pool.TransactOpts, CompletePools)
}

// CompletePoolAndNew is a paid mutator transaction binding the contract method 0x3338562c.
//
// Solidity: function CompletePoolAndNew((uint32,uint32,address,uint256,uint256,uint256,bool)[] CompletePools) payable returns()
func (_L1Pool *L1PoolTransactorSession) CompletePoolAndNew(CompletePools []IL1PoolPool) (*types.Transaction, error) {
	return _L1Pool.Contract.CompletePoolAndNew(&_L1Pool.TransactOpts, CompletePools)
}

// DepositAndStakingETH is a paid mutator transaction binding the contract method 0x96f984e6.
//
// Solidity: function DepositAndStakingETH() payable returns()
func (_L1Pool *L1PoolTransactor) DepositAndStakingETH(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "DepositAndStakingETH")
}

// DepositAndStakingETH is a paid mutator transaction binding the contract method 0x96f984e6.
//
// Solidity: function DepositAndStakingETH() payable returns()
func (_L1Pool *L1PoolSession) DepositAndStakingETH() (*types.Transaction, error) {
	return _L1Pool.Contract.DepositAndStakingETH(&_L1Pool.TransactOpts)
}

// DepositAndStakingETH is a paid mutator transaction binding the contract method 0x96f984e6.
//
// Solidity: function DepositAndStakingETH() payable returns()
func (_L1Pool *L1PoolTransactorSession) DepositAndStakingETH() (*types.Transaction, error) {
	return _L1Pool.Contract.DepositAndStakingETH(&_L1Pool.TransactOpts)
}

// DepositAndStakingWETH is a paid mutator transaction binding the contract method 0xbc42493d.
//
// Solidity: function DepositAndStakingWETH(uint256 amount) returns()
func (_L1Pool *L1PoolTransactor) DepositAndStakingWETH(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "DepositAndStakingWETH", amount)
}

// DepositAndStakingWETH is a paid mutator transaction binding the contract method 0xbc42493d.
//
// Solidity: function DepositAndStakingWETH(uint256 amount) returns()
func (_L1Pool *L1PoolSession) DepositAndStakingWETH(amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.DepositAndStakingWETH(&_L1Pool.TransactOpts, amount)
}

// DepositAndStakingWETH is a paid mutator transaction binding the contract method 0xbc42493d.
//
// Solidity: function DepositAndStakingWETH(uint256 amount) returns()
func (_L1Pool *L1PoolTransactorSession) DepositAndStakingWETH(amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.DepositAndStakingWETH(&_L1Pool.TransactOpts, amount)
}

// DepositAndStarking is a paid mutator transaction binding the contract method 0xf9f3ec9e.
//
// Solidity: function DepositAndStarking(address _token, uint256 _amount) payable returns()
func (_L1Pool *L1PoolTransactor) DepositAndStarking(opts *bind.TransactOpts, _token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "DepositAndStarking", _token, _amount)
}

// DepositAndStarking is a paid mutator transaction binding the contract method 0xf9f3ec9e.
//
// Solidity: function DepositAndStarking(address _token, uint256 _amount) payable returns()
func (_L1Pool *L1PoolSession) DepositAndStarking(_token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.DepositAndStarking(&_L1Pool.TransactOpts, _token, _amount)
}

// DepositAndStarking is a paid mutator transaction binding the contract method 0xf9f3ec9e.
//
// Solidity: function DepositAndStarking(address _token, uint256 _amount) payable returns()
func (_L1Pool *L1PoolTransactorSession) DepositAndStarking(_token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.DepositAndStarking(&_L1Pool.TransactOpts, _token, _amount)
}

// DepositAndStarkingERC20 is a paid mutator transaction binding the contract method 0x9845c5c3.
//
// Solidity: function DepositAndStarkingERC20(address _token, uint256 _amount) returns()
func (_L1Pool *L1PoolTransactor) DepositAndStarkingERC20(opts *bind.TransactOpts, _token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "DepositAndStarkingERC20", _token, _amount)
}

// DepositAndStarkingERC20 is a paid mutator transaction binding the contract method 0x9845c5c3.
//
// Solidity: function DepositAndStarkingERC20(address _token, uint256 _amount) returns()
func (_L1Pool *L1PoolSession) DepositAndStarkingERC20(_token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.DepositAndStarkingERC20(&_L1Pool.TransactOpts, _token, _amount)
}

// DepositAndStarkingERC20 is a paid mutator transaction binding the contract method 0x9845c5c3.
//
// Solidity: function DepositAndStarkingERC20(address _token, uint256 _amount) returns()
func (_L1Pool *L1PoolTransactorSession) DepositAndStarkingERC20(_token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.DepositAndStarkingERC20(&_L1Pool.TransactOpts, _token, _amount)
}

// SetSupportToken is a paid mutator transaction binding the contract method 0xfaeb96a5.
//
// Solidity: function SetSupportToken(address _token, bool _isSupport, uint32 startTimes) returns()
func (_L1Pool *L1PoolTransactor) SetSupportToken(opts *bind.TransactOpts, _token common.Address, _isSupport bool, startTimes uint32) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "SetSupportToken", _token, _isSupport, startTimes)
}

// SetSupportToken is a paid mutator transaction binding the contract method 0xfaeb96a5.
//
// Solidity: function SetSupportToken(address _token, bool _isSupport, uint32 startTimes) returns()
func (_L1Pool *L1PoolSession) SetSupportToken(_token common.Address, _isSupport bool, startTimes uint32) (*types.Transaction, error) {
	return _L1Pool.Contract.SetSupportToken(&_L1Pool.TransactOpts, _token, _isSupport, startTimes)
}

// SetSupportToken is a paid mutator transaction binding the contract method 0xfaeb96a5.
//
// Solidity: function SetSupportToken(address _token, bool _isSupport, uint32 startTimes) returns()
func (_L1Pool *L1PoolTransactorSession) SetSupportToken(_token common.Address, _isSupport bool, startTimes uint32) (*types.Transaction, error) {
	return _L1Pool.Contract.SetSupportToken(&_L1Pool.TransactOpts, _token, _isSupport, startTimes)
}

// TransferAssertToBridge is a paid mutator transaction binding the contract method 0xf91fa9a8.
//
// Solidity: function TransferAssertToBridge(uint256 Blockchain, address _token, address _to, uint256 _amount) returns()
func (_L1Pool *L1PoolTransactor) TransferAssertToBridge(opts *bind.TransactOpts, Blockchain *big.Int, _token common.Address, _to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "TransferAssertToBridge", Blockchain, _token, _to, _amount)
}

// TransferAssertToBridge is a paid mutator transaction binding the contract method 0xf91fa9a8.
//
// Solidity: function TransferAssertToBridge(uint256 Blockchain, address _token, address _to, uint256 _amount) returns()
func (_L1Pool *L1PoolSession) TransferAssertToBridge(Blockchain *big.Int, _token common.Address, _to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.TransferAssertToBridge(&_L1Pool.TransactOpts, Blockchain, _token, _to, _amount)
}

// TransferAssertToBridge is a paid mutator transaction binding the contract method 0xf91fa9a8.
//
// Solidity: function TransferAssertToBridge(uint256 Blockchain, address _token, address _to, uint256 _amount) returns()
func (_L1Pool *L1PoolTransactorSession) TransferAssertToBridge(Blockchain *big.Int, _token common.Address, _to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.TransferAssertToBridge(&_L1Pool.TransactOpts, Blockchain, _token, _to, _amount)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_L1Pool *L1PoolTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_L1Pool *L1PoolSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.GrantRole(&_L1Pool.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_L1Pool *L1PoolTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.GrantRole(&_L1Pool.TransactOpts, role, account)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _MultisigWallet) returns()
func (_L1Pool *L1PoolTransactor) Initialize(opts *bind.TransactOpts, _MultisigWallet common.Address) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "initialize", _MultisigWallet)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _MultisigWallet) returns()
func (_L1Pool *L1PoolSession) Initialize(_MultisigWallet common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.Initialize(&_L1Pool.TransactOpts, _MultisigWallet)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _MultisigWallet) returns()
func (_L1Pool *L1PoolTransactorSession) Initialize(_MultisigWallet common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.Initialize(&_L1Pool.TransactOpts, _MultisigWallet)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_L1Pool *L1PoolTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_L1Pool *L1PoolSession) Pause() (*types.Transaction, error) {
	return _L1Pool.Contract.Pause(&_L1Pool.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_L1Pool *L1PoolTransactorSession) Pause() (*types.Transaction, error) {
	return _L1Pool.Contract.Pause(&_L1Pool.TransactOpts)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address callerConfirmation) returns()
func (_L1Pool *L1PoolTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, callerConfirmation common.Address) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "renounceRole", role, callerConfirmation)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address callerConfirmation) returns()
func (_L1Pool *L1PoolSession) RenounceRole(role [32]byte, callerConfirmation common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.RenounceRole(&_L1Pool.TransactOpts, role, callerConfirmation)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address callerConfirmation) returns()
func (_L1Pool *L1PoolTransactorSession) RenounceRole(role [32]byte, callerConfirmation common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.RenounceRole(&_L1Pool.TransactOpts, role, callerConfirmation)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_L1Pool *L1PoolTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_L1Pool *L1PoolSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.RevokeRole(&_L1Pool.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_L1Pool *L1PoolTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _L1Pool.Contract.RevokeRole(&_L1Pool.TransactOpts, role, account)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xcb314fab.
//
// Solidity: function setMinStakeAmount(address _token, uint256 _amount) returns()
func (_L1Pool *L1PoolTransactor) SetMinStakeAmount(opts *bind.TransactOpts, _token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "setMinStakeAmount", _token, _amount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xcb314fab.
//
// Solidity: function setMinStakeAmount(address _token, uint256 _amount) returns()
func (_L1Pool *L1PoolSession) SetMinStakeAmount(_token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.SetMinStakeAmount(&_L1Pool.TransactOpts, _token, _amount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xcb314fab.
//
// Solidity: function setMinStakeAmount(address _token, uint256 _amount) returns()
func (_L1Pool *L1PoolTransactorSession) SetMinStakeAmount(_token common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _L1Pool.Contract.SetMinStakeAmount(&_L1Pool.TransactOpts, _token, _amount)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_L1Pool *L1PoolTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _L1Pool.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_L1Pool *L1PoolSession) Unpause() (*types.Transaction, error) {
	return _L1Pool.Contract.Unpause(&_L1Pool.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_L1Pool *L1PoolTransactorSession) Unpause() (*types.Transaction, error) {
	return _L1Pool.Contract.Unpause(&_L1Pool.TransactOpts)
}

// L1PoolClaimEventIterator is returned from FilterClaimEvent and is used to iterate over the raw logs and unpacked data for ClaimEvent events raised by the L1Pool contract.
type L1PoolClaimEventIterator struct {
	Event *L1PoolClaimEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolClaimEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolClaimEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolClaimEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolClaimEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolClaimEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolClaimEvent represents a ClaimEvent event raised by the L1Pool contract.
type L1PoolClaimEvent struct {
	User        common.Address
	StartPoolId *big.Int
	EndPoolId   *big.Int
	Token       common.Address
	Amount      *big.Int
	Fee         *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterClaimEvent is a free log retrieval operation binding the contract event 0x991c329471ab5230e2301ee30d0d6fba5906e32411d5d154d5a8c278d021a2ab.
//
// Solidity: event ClaimEvent(address indexed user, uint256 startPoolId, uint256 endPoolId, address indexed token, uint256 amount, uint256 fee)
func (_L1Pool *L1PoolFilterer) FilterClaimEvent(opts *bind.FilterOpts, user []common.Address, token []common.Address) (*L1PoolClaimEventIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "ClaimEvent", userRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolClaimEventIterator{contract: _L1Pool.contract, event: "ClaimEvent", logs: logs, sub: sub}, nil
}

// WatchClaimEvent is a free log subscription operation binding the contract event 0x991c329471ab5230e2301ee30d0d6fba5906e32411d5d154d5a8c278d021a2ab.
//
// Solidity: event ClaimEvent(address indexed user, uint256 startPoolId, uint256 endPoolId, address indexed token, uint256 amount, uint256 fee)
func (_L1Pool *L1PoolFilterer) WatchClaimEvent(opts *bind.WatchOpts, sink chan<- *L1PoolClaimEvent, user []common.Address, token []common.Address) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "ClaimEvent", userRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolClaimEvent)
				if err := _L1Pool.contract.UnpackLog(event, "ClaimEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseClaimEvent is a log parse operation binding the contract event 0x991c329471ab5230e2301ee30d0d6fba5906e32411d5d154d5a8c278d021a2ab.
//
// Solidity: event ClaimEvent(address indexed user, uint256 startPoolId, uint256 endPoolId, address indexed token, uint256 amount, uint256 fee)
func (_L1Pool *L1PoolFilterer) ParseClaimEvent(log types.Log) (*L1PoolClaimEvent, error) {
	event := new(L1PoolClaimEvent)
	if err := _L1Pool.contract.UnpackLog(event, "ClaimEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolCompletePoolEventIterator is returned from FilterCompletePoolEvent and is used to iterate over the raw logs and unpacked data for CompletePoolEvent events raised by the L1Pool contract.
type L1PoolCompletePoolEventIterator struct {
	Event *L1PoolCompletePoolEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolCompletePoolEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolCompletePoolEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolCompletePoolEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolCompletePoolEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolCompletePoolEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolCompletePoolEvent represents a CompletePoolEvent event raised by the L1Pool contract.
type L1PoolCompletePoolEvent struct {
	Token     common.Address
	PoolIndex *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterCompletePoolEvent is a free log retrieval operation binding the contract event 0xb6f449f07ceaf55392c9899e0797c6529908ae827c2d498c682e90d42c241167.
//
// Solidity: event CompletePoolEvent(address indexed token, uint256 poolIndex)
func (_L1Pool *L1PoolFilterer) FilterCompletePoolEvent(opts *bind.FilterOpts, token []common.Address) (*L1PoolCompletePoolEventIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "CompletePoolEvent", tokenRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolCompletePoolEventIterator{contract: _L1Pool.contract, event: "CompletePoolEvent", logs: logs, sub: sub}, nil
}

// WatchCompletePoolEvent is a free log subscription operation binding the contract event 0xb6f449f07ceaf55392c9899e0797c6529908ae827c2d498c682e90d42c241167.
//
// Solidity: event CompletePoolEvent(address indexed token, uint256 poolIndex)
func (_L1Pool *L1PoolFilterer) WatchCompletePoolEvent(opts *bind.WatchOpts, sink chan<- *L1PoolCompletePoolEvent, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "CompletePoolEvent", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolCompletePoolEvent)
				if err := _L1Pool.contract.UnpackLog(event, "CompletePoolEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCompletePoolEvent is a log parse operation binding the contract event 0xb6f449f07ceaf55392c9899e0797c6529908ae827c2d498c682e90d42c241167.
//
// Solidity: event CompletePoolEvent(address indexed token, uint256 poolIndex)
func (_L1Pool *L1PoolFilterer) ParseCompletePoolEvent(log types.Log) (*L1PoolCompletePoolEvent, error) {
	event := new(L1PoolCompletePoolEvent)
	if err := _L1Pool.contract.UnpackLog(event, "CompletePoolEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the L1Pool contract.
type L1PoolInitializedIterator struct {
	Event *L1PoolInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolInitialized represents a Initialized event raised by the L1Pool contract.
type L1PoolInitialized struct {
	Version uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_L1Pool *L1PoolFilterer) FilterInitialized(opts *bind.FilterOpts) (*L1PoolInitializedIterator, error) {

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &L1PoolInitializedIterator{contract: _L1Pool.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_L1Pool *L1PoolFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *L1PoolInitialized) (event.Subscription, error) {

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolInitialized)
				if err := _L1Pool.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_L1Pool *L1PoolFilterer) ParseInitialized(log types.Log) (*L1PoolInitialized, error) {
	event := new(L1PoolInitialized)
	if err := _L1Pool.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the L1Pool contract.
type L1PoolPausedIterator struct {
	Event *L1PoolPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolPaused represents a Paused event raised by the L1Pool contract.
type L1PoolPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_L1Pool *L1PoolFilterer) FilterPaused(opts *bind.FilterOpts) (*L1PoolPausedIterator, error) {

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &L1PoolPausedIterator{contract: _L1Pool.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_L1Pool *L1PoolFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *L1PoolPaused) (event.Subscription, error) {

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolPaused)
				if err := _L1Pool.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_L1Pool *L1PoolFilterer) ParsePaused(log types.Log) (*L1PoolPaused, error) {
	event := new(L1PoolPaused)
	if err := _L1Pool.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the L1Pool contract.
type L1PoolRoleAdminChangedIterator struct {
	Event *L1PoolRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolRoleAdminChanged represents a RoleAdminChanged event raised by the L1Pool contract.
type L1PoolRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_L1Pool *L1PoolFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*L1PoolRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolRoleAdminChangedIterator{contract: _L1Pool.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_L1Pool *L1PoolFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *L1PoolRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolRoleAdminChanged)
				if err := _L1Pool.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_L1Pool *L1PoolFilterer) ParseRoleAdminChanged(log types.Log) (*L1PoolRoleAdminChanged, error) {
	event := new(L1PoolRoleAdminChanged)
	if err := _L1Pool.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the L1Pool contract.
type L1PoolRoleGrantedIterator struct {
	Event *L1PoolRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolRoleGranted represents a RoleGranted event raised by the L1Pool contract.
type L1PoolRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_L1Pool *L1PoolFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*L1PoolRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolRoleGrantedIterator{contract: _L1Pool.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_L1Pool *L1PoolFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *L1PoolRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolRoleGranted)
				if err := _L1Pool.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_L1Pool *L1PoolFilterer) ParseRoleGranted(log types.Log) (*L1PoolRoleGranted, error) {
	event := new(L1PoolRoleGranted)
	if err := _L1Pool.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the L1Pool contract.
type L1PoolRoleRevokedIterator struct {
	Event *L1PoolRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolRoleRevoked represents a RoleRevoked event raised by the L1Pool contract.
type L1PoolRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_L1Pool *L1PoolFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*L1PoolRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolRoleRevokedIterator{contract: _L1Pool.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_L1Pool *L1PoolFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *L1PoolRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolRoleRevoked)
				if err := _L1Pool.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_L1Pool *L1PoolFilterer) ParseRoleRevoked(log types.Log) (*L1PoolRoleRevoked, error) {
	event := new(L1PoolRoleRevoked)
	if err := _L1Pool.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolSetMinStakeAmountEventIterator is returned from FilterSetMinStakeAmountEvent and is used to iterate over the raw logs and unpacked data for SetMinStakeAmountEvent events raised by the L1Pool contract.
type L1PoolSetMinStakeAmountEventIterator struct {
	Event *L1PoolSetMinStakeAmountEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolSetMinStakeAmountEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolSetMinStakeAmountEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolSetMinStakeAmountEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolSetMinStakeAmountEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolSetMinStakeAmountEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolSetMinStakeAmountEvent represents a SetMinStakeAmountEvent event raised by the L1Pool contract.
type L1PoolSetMinStakeAmountEvent struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterSetMinStakeAmountEvent is a free log retrieval operation binding the contract event 0xf54d3b756d286b6b08e5d4eda6dfe5b135664abf029e58e637cbf013c442c950.
//
// Solidity: event SetMinStakeAmountEvent(address indexed token, uint256 amount)
func (_L1Pool *L1PoolFilterer) FilterSetMinStakeAmountEvent(opts *bind.FilterOpts, token []common.Address) (*L1PoolSetMinStakeAmountEventIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "SetMinStakeAmountEvent", tokenRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolSetMinStakeAmountEventIterator{contract: _L1Pool.contract, event: "SetMinStakeAmountEvent", logs: logs, sub: sub}, nil
}

// WatchSetMinStakeAmountEvent is a free log subscription operation binding the contract event 0xf54d3b756d286b6b08e5d4eda6dfe5b135664abf029e58e637cbf013c442c950.
//
// Solidity: event SetMinStakeAmountEvent(address indexed token, uint256 amount)
func (_L1Pool *L1PoolFilterer) WatchSetMinStakeAmountEvent(opts *bind.WatchOpts, sink chan<- *L1PoolSetMinStakeAmountEvent, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "SetMinStakeAmountEvent", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolSetMinStakeAmountEvent)
				if err := _L1Pool.contract.UnpackLog(event, "SetMinStakeAmountEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetMinStakeAmountEvent is a log parse operation binding the contract event 0xf54d3b756d286b6b08e5d4eda6dfe5b135664abf029e58e637cbf013c442c950.
//
// Solidity: event SetMinStakeAmountEvent(address indexed token, uint256 amount)
func (_L1Pool *L1PoolFilterer) ParseSetMinStakeAmountEvent(log types.Log) (*L1PoolSetMinStakeAmountEvent, error) {
	event := new(L1PoolSetMinStakeAmountEvent)
	if err := _L1Pool.contract.UnpackLog(event, "SetMinStakeAmountEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolSetSupportTokenEventIterator is returned from FilterSetSupportTokenEvent and is used to iterate over the raw logs and unpacked data for SetSupportTokenEvent events raised by the L1Pool contract.
type L1PoolSetSupportTokenEventIterator struct {
	Event *L1PoolSetSupportTokenEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolSetSupportTokenEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolSetSupportTokenEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolSetSupportTokenEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolSetSupportTokenEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolSetSupportTokenEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolSetSupportTokenEvent represents a SetSupportTokenEvent event raised by the L1Pool contract.
type L1PoolSetSupportTokenEvent struct {
	Token     common.Address
	IsSupport bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSetSupportTokenEvent is a free log retrieval operation binding the contract event 0xc8c34f23fafb34e68119c1d231ef03d0d47225b15e2c4de3efbefa14b0181d86.
//
// Solidity: event SetSupportTokenEvent(address indexed token, bool isSupport)
func (_L1Pool *L1PoolFilterer) FilterSetSupportTokenEvent(opts *bind.FilterOpts, token []common.Address) (*L1PoolSetSupportTokenEventIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "SetSupportTokenEvent", tokenRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolSetSupportTokenEventIterator{contract: _L1Pool.contract, event: "SetSupportTokenEvent", logs: logs, sub: sub}, nil
}

// WatchSetSupportTokenEvent is a free log subscription operation binding the contract event 0xc8c34f23fafb34e68119c1d231ef03d0d47225b15e2c4de3efbefa14b0181d86.
//
// Solidity: event SetSupportTokenEvent(address indexed token, bool isSupport)
func (_L1Pool *L1PoolFilterer) WatchSetSupportTokenEvent(opts *bind.WatchOpts, sink chan<- *L1PoolSetSupportTokenEvent, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "SetSupportTokenEvent", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolSetSupportTokenEvent)
				if err := _L1Pool.contract.UnpackLog(event, "SetSupportTokenEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetSupportTokenEvent is a log parse operation binding the contract event 0xc8c34f23fafb34e68119c1d231ef03d0d47225b15e2c4de3efbefa14b0181d86.
//
// Solidity: event SetSupportTokenEvent(address indexed token, bool isSupport)
func (_L1Pool *L1PoolFilterer) ParseSetSupportTokenEvent(log types.Log) (*L1PoolSetSupportTokenEvent, error) {
	event := new(L1PoolSetSupportTokenEvent)
	if err := _L1Pool.contract.UnpackLog(event, "SetSupportTokenEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolStakingETHEventIterator is returned from FilterStakingETHEvent and is used to iterate over the raw logs and unpacked data for StakingETHEvent events raised by the L1Pool contract.
type L1PoolStakingETHEventIterator struct {
	Event *L1PoolStakingETHEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolStakingETHEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolStakingETHEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolStakingETHEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolStakingETHEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolStakingETHEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolStakingETHEvent represents a StakingETHEvent event raised by the L1Pool contract.
type L1PoolStakingETHEvent struct {
	User   common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterStakingETHEvent is a free log retrieval operation binding the contract event 0xe7466ea83435490635fc76a5f33da4815758ab48b1d45858f0452ca646556937.
//
// Solidity: event StakingETHEvent(address indexed user, uint256 amount)
func (_L1Pool *L1PoolFilterer) FilterStakingETHEvent(opts *bind.FilterOpts, user []common.Address) (*L1PoolStakingETHEventIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "StakingETHEvent", userRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolStakingETHEventIterator{contract: _L1Pool.contract, event: "StakingETHEvent", logs: logs, sub: sub}, nil
}

// WatchStakingETHEvent is a free log subscription operation binding the contract event 0xe7466ea83435490635fc76a5f33da4815758ab48b1d45858f0452ca646556937.
//
// Solidity: event StakingETHEvent(address indexed user, uint256 amount)
func (_L1Pool *L1PoolFilterer) WatchStakingETHEvent(opts *bind.WatchOpts, sink chan<- *L1PoolStakingETHEvent, user []common.Address) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "StakingETHEvent", userRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolStakingETHEvent)
				if err := _L1Pool.contract.UnpackLog(event, "StakingETHEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStakingETHEvent is a log parse operation binding the contract event 0xe7466ea83435490635fc76a5f33da4815758ab48b1d45858f0452ca646556937.
//
// Solidity: event StakingETHEvent(address indexed user, uint256 amount)
func (_L1Pool *L1PoolFilterer) ParseStakingETHEvent(log types.Log) (*L1PoolStakingETHEvent, error) {
	event := new(L1PoolStakingETHEvent)
	if err := _L1Pool.contract.UnpackLog(event, "StakingETHEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolStakingWETHEventIterator is returned from FilterStakingWETHEvent and is used to iterate over the raw logs and unpacked data for StakingWETHEvent events raised by the L1Pool contract.
type L1PoolStakingWETHEventIterator struct {
	Event *L1PoolStakingWETHEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolStakingWETHEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolStakingWETHEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolStakingWETHEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolStakingWETHEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolStakingWETHEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolStakingWETHEvent represents a StakingWETHEvent event raised by the L1Pool contract.
type L1PoolStakingWETHEvent struct {
	User   common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterStakingWETHEvent is a free log retrieval operation binding the contract event 0xc138e3bd6d13eefa5cb01c0d35c5794001141efaf4e5ad888cad059935f83383.
//
// Solidity: event StakingWETHEvent(address indexed user, uint256 amount)
func (_L1Pool *L1PoolFilterer) FilterStakingWETHEvent(opts *bind.FilterOpts, user []common.Address) (*L1PoolStakingWETHEventIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "StakingWETHEvent", userRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolStakingWETHEventIterator{contract: _L1Pool.contract, event: "StakingWETHEvent", logs: logs, sub: sub}, nil
}

// WatchStakingWETHEvent is a free log subscription operation binding the contract event 0xc138e3bd6d13eefa5cb01c0d35c5794001141efaf4e5ad888cad059935f83383.
//
// Solidity: event StakingWETHEvent(address indexed user, uint256 amount)
func (_L1Pool *L1PoolFilterer) WatchStakingWETHEvent(opts *bind.WatchOpts, sink chan<- *L1PoolStakingWETHEvent, user []common.Address) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "StakingWETHEvent", userRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolStakingWETHEvent)
				if err := _L1Pool.contract.UnpackLog(event, "StakingWETHEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStakingWETHEvent is a log parse operation binding the contract event 0xc138e3bd6d13eefa5cb01c0d35c5794001141efaf4e5ad888cad059935f83383.
//
// Solidity: event StakingWETHEvent(address indexed user, uint256 amount)
func (_L1Pool *L1PoolFilterer) ParseStakingWETHEvent(log types.Log) (*L1PoolStakingWETHEvent, error) {
	event := new(L1PoolStakingWETHEvent)
	if err := _L1Pool.contract.UnpackLog(event, "StakingWETHEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolStarkingERC20EventIterator is returned from FilterStarkingERC20Event and is used to iterate over the raw logs and unpacked data for StarkingERC20Event events raised by the L1Pool contract.
type L1PoolStarkingERC20EventIterator struct {
	Event *L1PoolStarkingERC20Event // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolStarkingERC20EventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolStarkingERC20Event)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolStarkingERC20Event)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolStarkingERC20EventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolStarkingERC20EventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolStarkingERC20Event represents a StarkingERC20Event event raised by the L1Pool contract.
type L1PoolStarkingERC20Event struct {
	User   common.Address
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterStarkingERC20Event is a free log retrieval operation binding the contract event 0x3ac7d3823c11677fba9479ed26f696a3f17e16a5a5c39162fa6d183905aa6735.
//
// Solidity: event StarkingERC20Event(address indexed user, address indexed token, uint256 amount)
func (_L1Pool *L1PoolFilterer) FilterStarkingERC20Event(opts *bind.FilterOpts, user []common.Address, token []common.Address) (*L1PoolStarkingERC20EventIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "StarkingERC20Event", userRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolStarkingERC20EventIterator{contract: _L1Pool.contract, event: "StarkingERC20Event", logs: logs, sub: sub}, nil
}

// WatchStarkingERC20Event is a free log subscription operation binding the contract event 0x3ac7d3823c11677fba9479ed26f696a3f17e16a5a5c39162fa6d183905aa6735.
//
// Solidity: event StarkingERC20Event(address indexed user, address indexed token, uint256 amount)
func (_L1Pool *L1PoolFilterer) WatchStarkingERC20Event(opts *bind.WatchOpts, sink chan<- *L1PoolStarkingERC20Event, user []common.Address, token []common.Address) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "StarkingERC20Event", userRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolStarkingERC20Event)
				if err := _L1Pool.contract.UnpackLog(event, "StarkingERC20Event", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStarkingERC20Event is a log parse operation binding the contract event 0x3ac7d3823c11677fba9479ed26f696a3f17e16a5a5c39162fa6d183905aa6735.
//
// Solidity: event StarkingERC20Event(address indexed user, address indexed token, uint256 amount)
func (_L1Pool *L1PoolFilterer) ParseStarkingERC20Event(log types.Log) (*L1PoolStarkingERC20Event, error) {
	event := new(L1PoolStarkingERC20Event)
	if err := _L1Pool.contract.UnpackLog(event, "StarkingERC20Event", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolTransferAssertToIterator is returned from FilterTransferAssertTo and is used to iterate over the raw logs and unpacked data for TransferAssertTo events raised by the L1Pool contract.
type L1PoolTransferAssertToIterator struct {
	Event *L1PoolTransferAssertTo // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolTransferAssertToIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolTransferAssertTo)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolTransferAssertTo)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolTransferAssertToIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolTransferAssertToIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolTransferAssertTo represents a TransferAssertTo event raised by the L1Pool contract.
type L1PoolTransferAssertTo struct {
	Blockchain *big.Int
	Token      common.Address
	To         common.Address
	Amount     *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterTransferAssertTo is a free log retrieval operation binding the contract event 0x08ffba656e4ac665e1aa4bb6a342e1a69d4cc12fd751ac862fa3fe27b0c7524a.
//
// Solidity: event TransferAssertTo(uint256 Blockchain, address indexed token, address indexed to, uint256 amount)
func (_L1Pool *L1PoolFilterer) FilterTransferAssertTo(opts *bind.FilterOpts, token []common.Address, to []common.Address) (*L1PoolTransferAssertToIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "TransferAssertTo", tokenRule, toRule)
	if err != nil {
		return nil, err
	}
	return &L1PoolTransferAssertToIterator{contract: _L1Pool.contract, event: "TransferAssertTo", logs: logs, sub: sub}, nil
}

// WatchTransferAssertTo is a free log subscription operation binding the contract event 0x08ffba656e4ac665e1aa4bb6a342e1a69d4cc12fd751ac862fa3fe27b0c7524a.
//
// Solidity: event TransferAssertTo(uint256 Blockchain, address indexed token, address indexed to, uint256 amount)
func (_L1Pool *L1PoolFilterer) WatchTransferAssertTo(opts *bind.WatchOpts, sink chan<- *L1PoolTransferAssertTo, token []common.Address, to []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "TransferAssertTo", tokenRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolTransferAssertTo)
				if err := _L1Pool.contract.UnpackLog(event, "TransferAssertTo", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferAssertTo is a log parse operation binding the contract event 0x08ffba656e4ac665e1aa4bb6a342e1a69d4cc12fd751ac862fa3fe27b0c7524a.
//
// Solidity: event TransferAssertTo(uint256 Blockchain, address indexed token, address indexed to, uint256 amount)
func (_L1Pool *L1PoolFilterer) ParseTransferAssertTo(log types.Log) (*L1PoolTransferAssertTo, error) {
	event := new(L1PoolTransferAssertTo)
	if err := _L1Pool.contract.UnpackLog(event, "TransferAssertTo", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// L1PoolUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the L1Pool contract.
type L1PoolUnpausedIterator struct {
	Event *L1PoolUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *L1PoolUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(L1PoolUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(L1PoolUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *L1PoolUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *L1PoolUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// L1PoolUnpaused represents a Unpaused event raised by the L1Pool contract.
type L1PoolUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_L1Pool *L1PoolFilterer) FilterUnpaused(opts *bind.FilterOpts) (*L1PoolUnpausedIterator, error) {

	logs, sub, err := _L1Pool.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &L1PoolUnpausedIterator{contract: _L1Pool.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_L1Pool *L1PoolFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *L1PoolUnpaused) (event.Subscription, error) {

	logs, sub, err := _L1Pool.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(L1PoolUnpaused)
				if err := _L1Pool.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_L1Pool *L1PoolFilterer) ParseUnpaused(log types.Log) (*L1PoolUnpaused, error) {
	event := new(L1PoolUnpaused)
	if err := _L1Pool.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
